1. In this lesson, you created a middleware function called asyncWrapper. Why?

The asyncWrapper middleware function is used to wrap the controllers, where we can 
invoke the try catch code blocks inside asyncWrapper and provide the error handling. 
The asyncWrapper returns another async function with parameters req, res, and next. 
Essentially, with the asyncWrapper we don't have to do a try catch block in every 
single controller.

2. Suppose that you want to make sure that both a status code and an error message 
are sent back to the user when they request the URL for a task that does not exist. 
Assume that youâ€™ve created a CustomAPIError class and an error handler that references 
that class. Complete the code:

const getTask = asyncWrapper(async (req, res, next) => {
    const {id: taskID} = req.params;
    const task = await Task.findOne({ _id: taskID });
    if (!task){
        return new CustomAPIError(`No task with id: ${ taskID }`, 404);
    }
    res.status(200).json({ task });
})


